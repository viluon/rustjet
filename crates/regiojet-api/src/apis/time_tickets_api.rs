/*
 * RegioJet API
 *
 * A set of endpoints to interact with RegioJet transport services. Search for connections, book tickets, see the list of served stations and more. All endpoints consume and produce JSON strings, with the exception of ticket printing (/tickets/{ticketId}/print) that produce printable HTML code.
 *
 * The version of the OpenAPI document: 1.2.0
 * Contact: developers@studentagency.cz
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, configuration};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for typed errors of method [`cancel_time_ticket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelTimeTicketError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_time_ticket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTimeTicketError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_unregistered_time_ticket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUnregisteredTimeTicketError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_time_tickets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllTimeTicketsError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_valid_time_tickets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllValidTimeTicketsError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_ticket_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeTicketByIdError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_ticket_qr_code`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeTicketQrCodeError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_ticket_qr_code_png`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeTicketQrCodePngError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_unpaid_time_tickets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUnpaidTimeTicketsError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`print_time_ticket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrintTimeTicketError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`print_time_ticket_pdf`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrintTimeTicketPdfError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_time_ticket_by_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendTimeTicketByEmailError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

pub async fn cancel_time_ticket(
    configuration: &configuration::Configuration,
    time_ticket_id: i64,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<models::SuccessResponse, Error<CancelTimeTicketError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_time_ticket_id = time_ticket_id;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/timeticket/{timeTicketId}",
        configuration.base_path,
        timeTicketId = p_path_time_ticket_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::SuccessResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SuccessResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelTimeTicketError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates time ticket flexi or line
pub async fn create_time_ticket(
    configuration: &configuration::Configuration,
    body: models::CreateRegisteredTimeTicketsRequest,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
    x_currency: Option<&str>,
    x_tx_token: Option<&str>,
) -> Result<i64, Error<CreateTimeTicketError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;
    let p_header_x_currency = x_currency;
    let p_header_x_tx_token = x_tx_token;

    let uri_str = format!("{}/tickets/timeticket", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_currency {
        req_builder = req_builder.header("X-Currency", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_tx_token {
        req_builder = req_builder.header("X-TxToken", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `i64`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `i64`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateTimeTicketError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create unregistered time ticket. Only FLEX time ticket type is allowed
pub async fn create_unregistered_time_ticket(
    configuration: &configuration::Configuration,
    body: models::CreateUnregisteredTimeTicketRequest,
    x_application_origin: Option<&str>,
    x_re_captcha_token: Option<&str>,
    x_lang: Option<&str>,
    x_currency: Option<&str>,
    x_tx_token: Option<&str>,
) -> Result<models::UnregisteredTimeTicketCreateInfo, Error<CreateUnregisteredTimeTicketError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_re_captcha_token = x_re_captcha_token;
    let p_header_x_lang = x_lang;
    let p_header_x_currency = x_currency;
    let p_header_x_tx_token = x_tx_token;

    let uri_str = format!(
        "{}/tickets/timetickets/unregistered",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_re_captcha_token {
        req_builder = req_builder.header("X-ReCaptcha-Token", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_currency {
        req_builder = req_builder.header("X-Currency", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_tx_token {
        req_builder = req_builder.header("X-TxToken", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::UnregisteredTimeTicketCreateInfo`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::UnregisteredTimeTicketCreateInfo`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateUnregisteredTimeTicketError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns the IDs of all time tickets and full info of all time tickets of a logged in user account.
pub async fn get_all_time_tickets(
    configuration: &configuration::Configuration,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
    limit: Option<i32>,
    offset: Option<i32>,
    departure_from: Option<String>,
    departure_to: Option<String>,
    arrival_from: Option<String>,
    arrival_to: Option<String>,
    ticket_states: Option<Vec<String>>,
    sort_direction: Option<&str>,
) -> Result<models::AccountTimeTickets, Error<GetAllTimeTicketsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;
    let p_query_limit = limit;
    let p_query_offset = offset;
    let p_query_departure_from = departure_from;
    let p_query_departure_to = departure_to;
    let p_query_arrival_from = arrival_from;
    let p_query_arrival_to = arrival_to;
    let p_query_ticket_states = ticket_states;
    let p_query_sort_direction = sort_direction;

    let uri_str = format!("{}/tickets/RJ_TIME", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_departure_from {
        req_builder = req_builder.query(&[("departureFrom", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_departure_to {
        req_builder = req_builder.query(&[("departureTo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_arrival_from {
        req_builder = req_builder.query(&[("arrivalFrom", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_arrival_to {
        req_builder = req_builder.query(&[("arrivalTo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ticket_states {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("ticketStates".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "ticketStates",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_sort_direction {
        req_builder = req_builder.query(&[("sortDirection", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::AccountTimeTickets`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::AccountTimeTickets`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAllTimeTicketsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns the IDs of all time tickets and full info of all time tickets of a logged in user account.
pub async fn get_all_valid_time_tickets(
    configuration: &configuration::Configuration,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
    limit: Option<i32>,
    offset: Option<i32>,
    valid_from: Option<String>,
    valid_to: Option<String>,
    ticket_states: Option<Vec<String>>,
    sort_direction: Option<&str>,
) -> Result<models::AccountTimeTickets, Error<GetAllValidTimeTicketsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;
    let p_query_limit = limit;
    let p_query_offset = offset;
    let p_query_valid_from = valid_from;
    let p_query_valid_to = valid_to;
    let p_query_ticket_states = ticket_states;
    let p_query_sort_direction = sort_direction;

    let uri_str = format!("{}/tickets/timetickets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_valid_from {
        req_builder = req_builder.query(&[("validFrom", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_valid_to {
        req_builder = req_builder.query(&[("validTo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ticket_states {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("ticketStates".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "ticketStates",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_sort_direction {
        req_builder = req_builder.query(&[("sortDirection", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::AccountTimeTickets`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::AccountTimeTickets`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAllValidTimeTicketsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_time_ticket_by_id(
    configuration: &configuration::Configuration,
    ticket_id: i64,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<models::TimeTicket, Error<GetTimeTicketByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_id = ticket_id;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/timeTickets/{ticketId}",
        configuration.base_path,
        ticketId = p_path_ticket_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::TimeTicket`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::TimeTicket`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeTicketByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get QR code content in CSV format (European CSV/DSV). Fields separated by the semicolon character and row does not terminate with the newline character.
pub async fn get_time_ticket_qr_code(
    configuration: &configuration::Configuration,
    ticket_id: i64,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<models::QrCodeTimeTicket, Error<GetTimeTicketQrCodeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_id = ticket_id;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/timeticket/{ticketId}/qrcode",
        configuration.base_path,
        ticketId = p_path_ticket_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::QrCodeTimeTicket`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::QrCodeTimeTicket`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeTicketQrCodeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get QR code as a PNG image
pub async fn get_time_ticket_qr_code_png(
    configuration: &configuration::Configuration,
    ticket_id: i64,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<models::QrCodeTimeTicket, Error<GetTimeTicketQrCodePngError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_id = ticket_id;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/timeticket/{ticketId}/qrcode/png",
        configuration.base_path,
        ticketId = p_path_ticket_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::QrCodeTimeTicket`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::QrCodeTimeTicket`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeTicketQrCodePngError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_unpaid_time_tickets(
    configuration: &configuration::Configuration,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<Vec<models::TimeTicket>, Error<GetUnpaidTimeTicketsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!("{}/tickets/timetickets/unpaid", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TimeTicket&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TimeTicket&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUnpaidTimeTicketsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Time ticket in pdf format
pub async fn print_time_ticket(
    configuration: &configuration::Configuration,
    time_ticket_id: i64,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<String, Error<PrintTimeTicketError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_time_ticket_id = time_ticket_id;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/timeticket/{timeTicketId}/print",
        configuration.base_path,
        timeTicketId = p_path_time_ticket_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `String`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `String`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PrintTimeTicketError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Note the unusual HTML output, not JSON like most other methods!
pub async fn print_time_ticket_pdf(
    configuration: &configuration::Configuration,
    time_ticket_id: i64,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<reqwest::Response, Error<PrintTimeTicketPdfError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_time_ticket_id = time_ticket_id;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/timeticket/{timeTicketId}/pdf",
        configuration.base_path,
        timeTicketId = p_path_time_ticket_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrintTimeTicketPdfError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn send_time_ticket_by_email(
    configuration: &configuration::Configuration,
    time_ticket_id: i64,
    email: models::TicketEmailRequest,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<(), Error<SendTimeTicketByEmailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_time_ticket_id = time_ticket_id;
    let p_body_email = email;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/timeticket/{timeTicketId}/sendByEmail",
        configuration.base_path,
        timeTicketId = p_path_time_ticket_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_email);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SendTimeTicketByEmailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
