/*
 * RegioJet API
 *
 * A set of endpoints to interact with RegioJet transport services. Search for connections, book tickets, see the list of served stations and more. All endpoints consume and produce JSON strings, with the exception of ticket printing (/tickets/{ticketId}/print) that produce printable HTML code.
 *
 * The version of the OpenAPI document: 1.2.0
 * Contact: developers@studentagency.cz
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, configuration};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for typed errors of method [`get_time_ticket_prices`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeTicketPricesError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

pub async fn get_time_ticket_prices(
    configuration: &configuration::Configuration,
    route_id: i64,
    from_station_id: i64,
    to_station_id: i64,
    time_ticket_type: &str,
    valid_from: String,
    tariff: &str,
    x_application_origin: Option<&str>,
    x_currency: Option<&str>,
) -> Result<Vec<models::TimeTicketPrice>, Error<GetTimeTicketPricesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_route_id = route_id;
    let p_path_from_station_id = from_station_id;
    let p_path_to_station_id = to_station_id;
    let p_path_time_ticket_type = time_ticket_type;
    let p_path_valid_from = valid_from;
    let p_path_tariff = tariff;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_currency = x_currency;

    let uri_str = format!(
        "{}/pricelists/timeticket/{routeId}/{fromStationId}/{toStationId}/{timeTicketType}/{validFrom}/{tariff}",
        configuration.base_path,
        routeId = p_path_route_id,
        fromStationId = p_path_from_station_id,
        toStationId = p_path_to_station_id,
        timeTicketType = crate::apis::urlencode(p_path_time_ticket_type),
        validFrom = p_path_valid_from,
        tariff = crate::apis::urlencode(p_path_tariff)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_currency {
        req_builder = req_builder.header("X-Currency", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TimeTicketPrice&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TimeTicketPrice&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeTicketPricesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
