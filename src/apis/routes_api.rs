/*
 * RegioJet API
 *
 * A set of endpoints to interact with RegioJet transport services. Search for connections, book tickets, see the list of served stations and more. All endpoints consume and produce JSON strings, with the exception of ticket printing (/tickets/{ticketId}/print) that produce printable HTML code.
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: developers@studentagency.cz
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, configuration};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for typed errors of method [`get_departures`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDeparturesError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_passengers_data`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPassengersDataError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_route_free_seats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRouteFreeSeatsError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_simple_route_detail`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimpleRouteDetailError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_routes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchRoutesError {
    Status400(models::ErrorResponse),
    Status404(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`simple_search_routes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SimpleSearchRoutesError {
    Status400(models::ErrorResponse),
    Status404(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

pub async fn get_departures(
    configuration: &configuration::Configuration,
    station_id: i64,
    x_lang: Option<&str>,
    limit: Option<i32>,
) -> Result<models::ArrivalDepartureConnection, Error<GetDeparturesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_station_id = station_id;
    let p_header_x_lang = x_lang;
    let p_query_limit = limit;

    let uri_str = format!(
        "{}/routes/{stationId}/departures",
        configuration.base_path,
        stationId = p_path_station_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::ArrivalDepartureConnection`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::ArrivalDepartureConnection`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDeparturesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_passengers_data(
    configuration: &configuration::Configuration,
    route_id: &str,
    filter: models::PassengersDataRequest,
    x_lang: Option<&str>,
    x_currency: Option<&str>,
) -> Result<models::PassengersDataResponse, Error<GetPassengersDataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_route_id = route_id;
    let p_body_filter = filter;
    let p_header_x_lang = x_lang;
    let p_header_x_currency = x_currency;

    let uri_str = format!(
        "{}/routes/{routeId}/passengersData",
        configuration.base_path,
        routeId = crate::apis::urlencode(p_path_route_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_currency {
        req_builder = req_builder.header("X-Currency", param_value.to_string());
    }
    req_builder = req_builder.json(&p_body_filter);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::PassengersDataResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::PassengersDataResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPassengersDataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_route_free_seats(
    configuration: &configuration::Configuration,
    route_id: &str,
    request: models::RouteSeatsRequest,
    x_lang: Option<&str>,
) -> Result<models::RouteSeatsResponse, Error<GetRouteFreeSeatsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_route_id = route_id;
    let p_body_request = request;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/routes/{routeId}/freeSeats",
        configuration.base_path,
        routeId = crate::apis::urlencode(p_path_route_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    req_builder = req_builder.json(&p_body_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::RouteSeatsResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::RouteSeatsResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRouteFreeSeatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_simple_route_detail(
    configuration: &configuration::Configuration,
    route_id: &str,
    from_station_id: i64,
    to_station_id: i64,
    x_lang: Option<&str>,
    x_currency: Option<&str>,
    tariffs: Option<Vec<String>>,
) -> Result<models::Route, Error<GetSimpleRouteDetailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_route_id = route_id;
    let p_query_from_station_id = from_station_id;
    let p_query_to_station_id = to_station_id;
    let p_header_x_lang = x_lang;
    let p_header_x_currency = x_currency;
    let p_query_tariffs = tariffs;

    let uri_str = format!(
        "{}/routes/{routeId}/simple",
        configuration.base_path,
        routeId = crate::apis::urlencode(p_path_route_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("fromStationId", &p_query_from_station_id.to_string())]);
    req_builder = req_builder.query(&[("toStationId", &p_query_to_station_id.to_string())]);
    if let Some(ref param_value) = p_query_tariffs {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("tariffs".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "tariffs",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_currency {
        req_builder = req_builder.header("X-Currency", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::Route`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Route`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSimpleRouteDetailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Authorization not required (filtres info bubbles)
pub async fn search_routes(
    configuration: &configuration::Configuration,
    from_location_id: i64,
    from_location_type: &str,
    to_location_id: i64,
    to_location_type: &str,
    x_lang: Option<&str>,
    x_currency: Option<&str>,
    departure_time: Option<String>,
    tariffs: Option<Vec<String>>,
    action_price: Option<&str>,
) -> Result<models::SearchResult, Error<SearchRoutesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_from_location_id = from_location_id;
    let p_query_from_location_type = from_location_type;
    let p_query_to_location_id = to_location_id;
    let p_query_to_location_type = to_location_type;
    let p_header_x_lang = x_lang;
    let p_header_x_currency = x_currency;
    let p_query_departure_time = departure_time;
    let p_query_tariffs = tariffs;
    let p_query_action_price = action_price;

    let uri_str = format!("{}/routes/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("fromLocationId", &p_query_from_location_id.to_string())]);
    req_builder =
        req_builder.query(&[("fromLocationType", &p_query_from_location_type.to_string())]);
    req_builder = req_builder.query(&[("toLocationId", &p_query_to_location_id.to_string())]);
    req_builder = req_builder.query(&[("toLocationType", &p_query_to_location_type.to_string())]);
    if let Some(ref param_value) = p_query_departure_time {
        req_builder = req_builder.query(&[("departureTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tariffs {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("tariffs".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "tariffs",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_action_price {
        req_builder = req_builder.query(&[("actionPrice", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_currency {
        req_builder = req_builder.header("X-Currency", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::SearchResult`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SearchResult`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchRoutesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Authorization not required (filtres info bubbles)
pub async fn simple_search_routes(
    configuration: &configuration::Configuration,
    from_location_id: i64,
    from_location_type: &str,
    to_location_id: i64,
    to_location_type: &str,
    x_lang: Option<&str>,
    x_currency: Option<&str>,
    x_used_departure_from_date_time: Option<String>,
    x_used_departure_to_date_time: Option<String>,
    departure_date: Option<String>,
    tariffs: Option<Vec<String>>,
    action_price: Option<&str>,
    r#move: Option<&str>,
) -> Result<models::SimpleSearchResult, Error<SimpleSearchRoutesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_from_location_id = from_location_id;
    let p_query_from_location_type = from_location_type;
    let p_query_to_location_id = to_location_id;
    let p_query_to_location_type = to_location_type;
    let p_header_x_lang = x_lang;
    let p_header_x_currency = x_currency;
    let p_header_x_used_departure_from_date_time = x_used_departure_from_date_time;
    let p_header_x_used_departure_to_date_time = x_used_departure_to_date_time;
    let p_query_departure_date = departure_date;
    let p_query_tariffs = tariffs;
    let p_query_action_price = action_price;
    let p_query_move = r#move;

    let uri_str = format!("{}/routes/search/simple", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("fromLocationId", &p_query_from_location_id.to_string())]);
    req_builder =
        req_builder.query(&[("fromLocationType", &p_query_from_location_type.to_string())]);
    req_builder = req_builder.query(&[("toLocationId", &p_query_to_location_id.to_string())]);
    req_builder = req_builder.query(&[("toLocationType", &p_query_to_location_type.to_string())]);
    if let Some(ref param_value) = p_query_departure_date {
        req_builder = req_builder.query(&[("departureDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tariffs {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("tariffs".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "tariffs",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_action_price {
        req_builder = req_builder.query(&[("actionPrice", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_move {
        req_builder = req_builder.query(&[("move", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_currency {
        req_builder = req_builder.header("X-Currency", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_used_departure_from_date_time {
        req_builder = req_builder.header("X-Used-DepartureFromDateTime", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_used_departure_to_date_time {
        req_builder = req_builder.header("X-Used-DepartureToDateTime", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::SimpleSearchResult`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SimpleSearchResult`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SimpleSearchRoutesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
