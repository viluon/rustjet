/*
 * RegioJet API
 *
 * A set of endpoints to interact with RegioJet transport services. Search for connections, book tickets, see the list of served stations and more. All endpoints consume and produce JSON strings, with the exception of ticket printing (/tickets/{ticketId}/print) that produce printable HTML code.
 *
 * The version of the OpenAPI document: 1.2.0
 * Contact: developers@studentagency.cz
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, configuration};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for typed errors of method [`add_to_google_wallet`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddToGoogleWalletError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status502(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`authenticate_limited_use`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthenticateLimitedUseError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cancel_ticket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelTicketError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cancel_ticket_by_affiliate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelTicketByAffiliateError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_selected_seats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeSelectedSeatsError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_registered_tickets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRegisteredTicketsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_sro_tickets_as_registered_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSroTicketsAsRegisteredUserError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_sro_tickets_as_unregistered_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSroTicketsAsUnregisteredUserError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_tickets_by_affiliate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTicketsByAffiliateError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_unregistered_tickets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUnregisteredTicketsError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_passenger`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeletePassengerError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_qr_code`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountQrCodeError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_qr_code_png`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountQrCodePngError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_tickets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllTicketsError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_tickets_for_affiliate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllTicketsForAffiliateError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_questionnaire_urls`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetQuestionnaireUrlsError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_section_detail_rating`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSectionDetailRatingError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ticket_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTicketByIdError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ticket_by_idfor_affiliate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTicketByIdforAffiliateError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ticket_detail_rating`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTicketDetailRatingError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ticket_png_qr_code`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTicketPngQrCodeError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ticket_qr_code`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTicketQrCodeError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ticket_qr_code_png`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTicketQrCodePngError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_unpaid_tickets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUnpaidTicketsError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`print_ticket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrintTicketError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`print_ticket_pdf`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrintTicketPdfError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_ticket_detail_rating`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutTicketDetailRatingError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_by_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendByEmailError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_ticket_by_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendTicketByEmailError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`submit_wheel_chair_platform_order`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubmitWheelChairPlatformOrderError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_passenger`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdatePassengerError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

pub async fn add_to_google_wallet(
    configuration: &configuration::Configuration,
    ticket_id: i64,
    x_lang: Option<&str>,
    x_application_origin: Option<&str>,
) -> Result<(), Error<AddToGoogleWalletError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_id = ticket_id;
    let p_header_x_lang = x_lang;
    let p_header_x_application_origin = x_application_origin;

    let uri_str = format!(
        "{}/tickets/{ticketId}/google-wallet",
        configuration.base_path,
        ticketId = p_path_ticket_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AddToGoogleWalletError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// User's authentication based on hash for limited use.
pub async fn authenticate_limited_use(
    configuration: &configuration::Configuration,
    hash: &str,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<models::Token, Error<AuthenticateLimitedUseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_hash = hash;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/authenticate/{hash}",
        configuration.base_path,
        hash = crate::apis::urlencode(p_path_hash)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::Token`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Token`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthenticateLimitedUseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn cancel_ticket(
    configuration: &configuration::Configuration,
    ticket_id: i64,
    request: models::CancelTicketRequest,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<models::SuccessResponse, Error<CancelTicketError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_id = ticket_id;
    let p_body_request = request;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/{ticketId}/cancel",
        configuration.base_path,
        ticketId = p_path_ticket_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::SuccessResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SuccessResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelTicketError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn cancel_ticket_by_affiliate(
    configuration: &configuration::Configuration,
    account_code: &str,
    ticket_id: i64,
    request: models::CancelTicketRequest,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<models::SuccessResponse, Error<CancelTicketByAffiliateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_account_code = account_code;
    let p_path_ticket_id = ticket_id;
    let p_body_request = request;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/{accountCode}/{ticketId}/cancel/affiliate",
        configuration.base_path,
        accountCode = crate::apis::urlencode(p_path_account_code),
        ticketId = p_path_ticket_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::SuccessResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SuccessResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelTicketByAffiliateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn change_selected_seats(
    configuration: &configuration::Configuration,
    ticket_id: i64,
    ticket_sections: Vec<models::CreateTicketSectionRequest>,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
    x_tx_token: Option<&str>,
) -> Result<models::SuccessResponse, Error<ChangeSelectedSeatsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_id = ticket_id;
    let p_body_ticket_sections = ticket_sections;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;
    let p_header_x_tx_token = x_tx_token;

    let uri_str = format!(
        "{}/tickets/{ticketId}/seats",
        configuration.base_path,
        ticketId = p_path_ticket_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_tx_token {
        req_builder = req_builder.header("X-TxToken", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_ticket_sections);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::SuccessResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SuccessResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangeSelectedSeatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn create_registered_tickets(
    configuration: &configuration::Configuration,
    tickets_request: models::CreateRegisteredTicketRequest,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
    x_currency: Option<&str>,
) -> Result<models::CreateTicketResponseRegistered, Error<CreateRegisteredTicketsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_tickets_request = tickets_request;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;
    let p_header_x_currency = x_currency;

    let uri_str = format!("{}/tickets/create/registered", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_currency {
        req_builder = req_builder.header("X-Currency", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_tickets_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::CreateTicketResponseRegistered`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::CreateTicketResponseRegistered`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateRegisteredTicketsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates seat reservation as registered user.
pub async fn create_sro_tickets_as_registered_user(
    configuration: &configuration::Configuration,
    body: models::CreateSroTicketsAsRegisteredUserRequest,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
    x_currency: Option<&str>,
    x_tx_token: Option<&str>,
) -> Result<models::Token, Error<CreateSroTicketsAsRegisteredUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;
    let p_header_x_currency = x_currency;
    let p_header_x_tx_token = x_tx_token;

    let uri_str = format!("{}/tickets/RJ_SRO/registered", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_currency {
        req_builder = req_builder.header("X-Currency", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_tx_token {
        req_builder = req_builder.header("X-TxToken", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::Token`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Token`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSroTicketsAsRegisteredUserError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates seat reservation as unregistered user.
pub async fn create_sro_tickets_as_unregistered_user(
    configuration: &configuration::Configuration,
    body: models::CreateSroTicketsAsUnregisteredUserRequest,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
    x_currency: Option<&str>,
    x_re_captcha_token: Option<&str>,
    x_body_hash: Option<&str>,
    x_tx_token: Option<&str>,
) -> Result<models::Token, Error<CreateSroTicketsAsUnregisteredUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;
    let p_header_x_currency = x_currency;
    let p_header_x_re_captcha_token = x_re_captcha_token;
    let p_header_x_body_hash = x_body_hash;
    let p_header_x_tx_token = x_tx_token;

    let uri_str = format!("{}/tickets/RJ_SRO/unregistered", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_currency {
        req_builder = req_builder.header("X-Currency", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_re_captcha_token {
        req_builder = req_builder.header("X-ReCaptcha-Token", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_body_hash {
        req_builder = req_builder.header("X-Body-Hash", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_tx_token {
        req_builder = req_builder.header("X-TxToken", param_value.to_string());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::Token`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Token`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSroTicketsAsUnregisteredUserError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn create_tickets_by_affiliate(
    configuration: &configuration::Configuration,
    tickets_request: models::CreateUnregisteredTicketRequestAffiliate,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
    x_currency: Option<&str>,
) -> Result<models::CreateTicketResponseUnregisteredAffiliate, Error<CreateTicketsByAffiliateError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_tickets_request = tickets_request;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;
    let p_header_x_currency = x_currency;

    let uri_str = format!("{}/tickets/create/affiliate", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_currency {
        req_builder = req_builder.header("X-Currency", param_value.to_string());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body_tickets_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::CreateTicketResponseUnregisteredAffiliate`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::CreateTicketResponseUnregisteredAffiliate`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateTicketsByAffiliateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn create_unregistered_tickets(
    configuration: &configuration::Configuration,
    tickets_request: models::CreateUnregisteredTicketRequest,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
    x_currency: Option<&str>,
    x_body_hash: Option<&str>,
    x_re_captcha_token: Option<&str>,
) -> Result<models::CreateTicketResponseUnregistered, Error<CreateUnregisteredTicketsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_tickets_request = tickets_request;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;
    let p_header_x_currency = x_currency;
    let p_header_x_body_hash = x_body_hash;
    let p_header_x_re_captcha_token = x_re_captcha_token;

    let uri_str = format!("{}/tickets/create/unregistered", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_currency {
        req_builder = req_builder.header("X-Currency", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_body_hash {
        req_builder = req_builder.header("X-Body-Hash", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_re_captcha_token {
        req_builder = req_builder.header("X-ReCaptcha-Token", param_value.to_string());
    }
    req_builder = req_builder.json(&p_body_tickets_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::CreateTicketResponseUnregistered`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::CreateTicketResponseUnregistered`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateUnregisteredTicketsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn delete_passenger(
    configuration: &configuration::Configuration,
    ticket_id: i64,
    passenger_id: i64,
    request: models::DeletePassengerRequest,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<models::SuccessResponse, Error<DeletePassengerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_id = ticket_id;
    let p_path_passenger_id = passenger_id;
    let p_body_request = request;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/{ticketId}/passengers/{passengerId}",
        configuration.base_path,
        ticketId = p_path_ticket_id,
        passengerId = p_path_passenger_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::SuccessResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SuccessResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeletePassengerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get QR code content in CSV format (European CSV/DSV). Fields separated by the semicolon character and row does not terminate with the newline character.
pub async fn get_account_qr_code(
    configuration: &configuration::Configuration,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<models::QrCodeAccount, Error<GetAccountQrCodeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!("{}/tickets/account/qrcode", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::QrCodeAccount`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::QrCodeAccount`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountQrCodeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get QR code as a PNG image
pub async fn get_account_qr_code_png(
    configuration: &configuration::Configuration,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<models::QrCodeAccount, Error<GetAccountQrCodePngError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!("{}/tickets/account/qrcode/png", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::QrCodeAccount`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::QrCodeAccount`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountQrCodePngError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_all_tickets(
    configuration: &configuration::Configuration,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
    limit: Option<i32>,
    offset: Option<i32>,
    departure_from: Option<String>,
    departure_to: Option<String>,
    arrival_from: Option<String>,
    arrival_to: Option<String>,
    ticket_states: Option<Vec<String>>,
    sort_property: Option<&str>,
    sort_direction: Option<&str>,
    simple: Option<bool>,
    catering_enabled: Option<bool>,
) -> Result<Vec<models::Ticket>, Error<GetAllTicketsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;
    let p_query_limit = limit;
    let p_query_offset = offset;
    let p_query_departure_from = departure_from;
    let p_query_departure_to = departure_to;
    let p_query_arrival_from = arrival_from;
    let p_query_arrival_to = arrival_to;
    let p_query_ticket_states = ticket_states;
    let p_query_sort_property = sort_property;
    let p_query_sort_direction = sort_direction;
    let p_query_simple = simple;
    let p_query_catering_enabled = catering_enabled;

    let uri_str = format!("{}/tickets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_departure_from {
        req_builder = req_builder.query(&[("departureFrom", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_departure_to {
        req_builder = req_builder.query(&[("departureTo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_arrival_from {
        req_builder = req_builder.query(&[("arrivalFrom", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_arrival_to {
        req_builder = req_builder.query(&[("arrivalTo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ticket_states {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("ticketStates".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "ticketStates",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_sort_property {
        req_builder = req_builder.query(&[("sortProperty", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_sort_direction {
        req_builder = req_builder.query(&[("sortDirection", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_simple {
        req_builder = req_builder.query(&[("simple", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_catering_enabled {
        req_builder = req_builder.query(&[("cateringEnabled", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Ticket&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Ticket&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAllTicketsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_all_tickets_for_affiliate(
    configuration: &configuration::Configuration,
    account_code: &str,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
    limit: Option<i32>,
    offset: Option<i32>,
    departure_from: Option<String>,
    departure_to: Option<String>,
    arrival_from: Option<String>,
    arrival_to: Option<String>,
    ticket_states: Option<Vec<String>>,
    sort_property: Option<&str>,
    sort_direction: Option<&str>,
) -> Result<Vec<models::TicketAffiliate>, Error<GetAllTicketsForAffiliateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_account_code = account_code;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;
    let p_query_limit = limit;
    let p_query_offset = offset;
    let p_query_departure_from = departure_from;
    let p_query_departure_to = departure_to;
    let p_query_arrival_from = arrival_from;
    let p_query_arrival_to = arrival_to;
    let p_query_ticket_states = ticket_states;
    let p_query_sort_property = sort_property;
    let p_query_sort_direction = sort_direction;

    let uri_str = format!(
        "{}/tickets/{accountCode}/affiliate",
        configuration.base_path,
        accountCode = crate::apis::urlencode(p_path_account_code)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_departure_from {
        req_builder = req_builder.query(&[("departureFrom", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_departure_to {
        req_builder = req_builder.query(&[("departureTo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_arrival_from {
        req_builder = req_builder.query(&[("arrivalFrom", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_arrival_to {
        req_builder = req_builder.query(&[("arrivalTo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ticket_states {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("ticketStates".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "ticketStates",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_sort_property {
        req_builder = req_builder.query(&[("sortProperty", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_sort_direction {
        req_builder = req_builder.query(&[("sortDirection", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TicketAffiliate&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TicketAffiliate&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAllTicketsForAffiliateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_questionnaire_urls(
    configuration: &configuration::Configuration,
    ticket_code: &str,
    x_lang: Option<&str>,
    x_application_origin: Option<&str>,
) -> Result<Vec<String>, Error<GetQuestionnaireUrlsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_code = ticket_code;
    let p_header_x_lang = x_lang;
    let p_header_x_application_origin = x_application_origin;

    let uri_str = format!(
        "{}/tickets/{ticketCode}/questionnaireUrls",
        configuration.base_path,
        ticketCode = crate::apis::urlencode(p_path_ticket_code)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetQuestionnaireUrlsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a rating form for the given section of a ticket.
pub async fn get_section_detail_rating(
    configuration: &configuration::Configuration,
    ticket_id: i64,
    section_id: i64,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<models::RatingFormData, Error<GetSectionDetailRatingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_id = ticket_id;
    let p_path_section_id = section_id;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/{ticketId}/sections/{sectionId}/rating",
        configuration.base_path,
        ticketId = p_path_ticket_id,
        sectionId = p_path_section_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::RatingFormData`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::RatingFormData`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSectionDetailRatingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_ticket_by_id(
    configuration: &configuration::Configuration,
    ticket_id: i64,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<models::Ticket, Error<GetTicketByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_id = ticket_id;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/{ticketId}",
        configuration.base_path,
        ticketId = p_path_ticket_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::Ticket`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Ticket`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTicketByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_ticket_by_idfor_affiliate(
    configuration: &configuration::Configuration,
    ticket_id: i64,
    account_code: &str,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<models::TicketAffiliate, Error<GetTicketByIdforAffiliateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_id = ticket_id;
    let p_path_account_code = account_code;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/{accountCode}/{ticketId}/affiliate",
        configuration.base_path,
        ticketId = p_path_ticket_id,
        accountCode = crate::apis::urlencode(p_path_account_code)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::TicketAffiliate`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::TicketAffiliate`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTicketByIdforAffiliateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_ticket_detail_rating(
    configuration: &configuration::Configuration,
    ticket_id: i64,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<Vec<models::RatingFormData>, Error<GetTicketDetailRatingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_id = ticket_id;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/{ticketId}/rating",
        configuration.base_path,
        ticketId = p_path_ticket_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::RatingFormData&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::RatingFormData&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTicketDetailRatingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get QR code as a PNG image
pub async fn get_ticket_png_qr_code(
    configuration: &configuration::Configuration,
    ticket_type: &str,
    ticket_id: i64,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<String, Error<GetTicketPngQrCodeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_type = ticket_type;
    let p_path_ticket_id = ticket_id;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/{ticketType}/{ticketId}/qrcode/png",
        configuration.base_path,
        ticketType = crate::apis::urlencode(p_path_ticket_type),
        ticketId = p_path_ticket_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `String`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `String`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTicketPngQrCodeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get QR code content in CSV format (European CSV/DSV). Fields separated by the semicolon character and row does not terminate with the newline character.
pub async fn get_ticket_qr_code(
    configuration: &configuration::Configuration,
    ticket_id: i64,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<models::QrCodeTicket, Error<GetTicketQrCodeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_id = ticket_id;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/{ticketId}/qrcode",
        configuration.base_path,
        ticketId = p_path_ticket_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::QrCodeTicket`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::QrCodeTicket`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTicketQrCodeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get QR code as a PNG image
pub async fn get_ticket_qr_code_png(
    configuration: &configuration::Configuration,
    ticket_id: i64,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<models::QrCodeTicket, Error<GetTicketQrCodePngError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_id = ticket_id;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/{ticketId}/qrcode/png",
        configuration.base_path,
        ticketId = p_path_ticket_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::QrCodeTicket`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::QrCodeTicket`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTicketQrCodePngError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_unpaid_tickets(
    configuration: &configuration::Configuration,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
    sort_property: Option<&str>,
    sort_direction: Option<&str>,
) -> Result<Vec<models::Ticket>, Error<GetUnpaidTicketsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;
    let p_query_sort_property = sort_property;
    let p_query_sort_direction = sort_direction;

    let uri_str = format!("{}/tickets/unpaid", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_sort_property {
        req_builder = req_builder.query(&[("sortProperty", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_sort_direction {
        req_builder = req_builder.query(&[("sortDirection", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Ticket&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Ticket&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUnpaidTicketsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Note the unusual HTML output, not JSON like most other methods!
pub async fn print_ticket(
    configuration: &configuration::Configuration,
    ticket_id: i64,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<String, Error<PrintTicketError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_id = ticket_id;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/{ticketId}/print",
        configuration.base_path,
        ticketId = p_path_ticket_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `String`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `String`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PrintTicketError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get ticket / time ticket / seat reservation in PDF format
pub async fn print_ticket_pdf(
    configuration: &configuration::Configuration,
    ticket_type: &str,
    ticket_id: i64,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<reqwest::Response, Error<PrintTicketPdfError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_type = ticket_type;
    let p_path_ticket_id = ticket_id;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/{ticketType}/{ticketId}/pdf",
        configuration.base_path,
        ticketType = crate::apis::urlencode(p_path_ticket_type),
        ticketId = p_path_ticket_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrintTicketPdfError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn put_ticket_detail_rating(
    configuration: &configuration::Configuration,
    ticket_id: i64,
    rating: models::PutRatingRequest,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<models::SuccessResponse, Error<PutTicketDetailRatingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_id = ticket_id;
    let p_body_rating = rating;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/{ticketId}/rating",
        configuration.base_path,
        ticketId = p_path_ticket_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_rating);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::SuccessResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SuccessResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PutTicketDetailRatingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn send_by_email(
    configuration: &configuration::Configuration,
    ticket_type: &str,
    ticket_id: i64,
    email: models::TicketEmailRequest,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<(), Error<SendByEmailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_type = ticket_type;
    let p_path_ticket_id = ticket_id;
    let p_body_email = email;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/{ticketType}/{ticketId}/sendByEmail",
        configuration.base_path,
        ticketType = crate::apis::urlencode(p_path_ticket_type),
        ticketId = p_path_ticket_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_email);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SendByEmailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn send_ticket_by_email(
    configuration: &configuration::Configuration,
    ticket_id: i64,
    email: models::TicketEmailRequest,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<models::SuccessResponse, Error<SendTicketByEmailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_id = ticket_id;
    let p_body_email = email;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/{ticketId}/sendByEmail",
        configuration.base_path,
        ticketId = p_path_ticket_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_email);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::SuccessResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SuccessResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SendTicketByEmailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn submit_wheel_chair_platform_order(
    configuration: &configuration::Configuration,
    ticket_id: i64,
    wheel_chair_platform_order: models::WheelChairPlatformOrder,
    x_application_origin: Option<&str>,
) -> Result<(), Error<SubmitWheelChairPlatformOrderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_id = ticket_id;
    let p_body_wheel_chair_platform_order = wheel_chair_platform_order;
    let p_header_x_application_origin = x_application_origin;

    let uri_str = format!(
        "{}/tickets/{ticketId}/submitWheelChairPlatformOrder",
        configuration.base_path,
        ticketId = p_path_ticket_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_wheel_chair_platform_order);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SubmitWheelChairPlatformOrderError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn update_passenger(
    configuration: &configuration::Configuration,
    ticket_id: i64,
    passenger_id: i64,
    passenger: models::PassengerRequest,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<models::PassengerChangeResponse, Error<UpdatePassengerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ticket_id = ticket_id;
    let p_path_passenger_id = passenger_id;
    let p_body_passenger = passenger;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/{ticketId}/passengers/{passengerId}",
        configuration.base_path,
        ticketId = p_path_ticket_id,
        passengerId = p_path_passenger_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_passenger);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::PassengerChangeResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::PassengerChangeResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdatePassengerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
