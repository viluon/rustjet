/*
 * RegioJet API
 *
 * A set of endpoints to interact with RegioJet transport services. Search for connections, book tickets, see the list of served stations and more. All endpoints consume and produce JSON strings, with the exception of ticket printing (/tickets/{ticketId}/print) that produce printable HTML code.
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: developers@studentagency.cz
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, configuration};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for typed errors of method [`consts_translations_language_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConstsTranslationsLanguageGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_action_prices`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetActionPricesError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_carriers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCarriersError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_city_pairs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCityPairsError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_locations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLocationsError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_online_paymenth_methods`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOnlinePaymenthMethodsError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_seat_classes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSeatClassesError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_tariffs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTariffsError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_timetables`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimetablesError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_vehicle_standards`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVehicleStandardsError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

pub async fn consts_translations_language_get(
    configuration: &configuration::Configuration,
    language: &str,
) -> Result<std::collections::HashMap<String, String>, Error<ConstsTranslationsLanguageGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_language = language;

    let uri_str = format!(
        "{}/consts/translations/{language}",
        configuration.base_path,
        language = crate::apis::urlencode(p_path_language)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, String&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, String&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConstsTranslationsLanguageGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_action_prices(
    configuration: &configuration::Configuration,
    x_lang: Option<&str>,
    active_only: Option<bool>,
) -> Result<Vec<models::ActionPrice>, Error<GetActionPricesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_lang = x_lang;
    let p_query_active_only = active_only;

    let uri_str = format!("{}/consts/actionPrices", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_active_only {
        req_builder = req_builder.query(&[("activeOnly", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ActionPrice&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ActionPrice&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetActionPricesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_carriers(
    configuration: &configuration::Configuration,
    x_lang: Option<&str>,
) -> Result<Vec<models::Carrier>, Error<GetCarriersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_lang = x_lang;

    let uri_str = format!("{}/consts/carriers", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Carrier&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Carrier&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCarriersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_city_pairs(
    configuration: &configuration::Configuration,
    x_lang: Option<&str>,
    x_currency: Option<&str>,
    from_city_id: Option<i64>,
    to_city_id: Option<i64>,
    number_of_transfers: Option<i32>,
) -> Result<Vec<models::CityPair>, Error<GetCityPairsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_lang = x_lang;
    let p_header_x_currency = x_currency;
    let p_query_from_city_id = from_city_id;
    let p_query_to_city_id = to_city_id;
    let p_query_number_of_transfers = number_of_transfers;

    let uri_str = format!("{}/consts/cityPairs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_from_city_id {
        req_builder = req_builder.query(&[("fromCityId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_to_city_id {
        req_builder = req_builder.query(&[("toCityId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_number_of_transfers {
        req_builder = req_builder.query(&[("numberOfTransfers", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_currency {
        req_builder = req_builder.header("X-Currency", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::CityPair&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::CityPair&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCityPairsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_locations(
    configuration: &configuration::Configuration,
    x_lang: Option<&str>,
    station_type: Option<&str>,
) -> Result<Vec<models::Country>, Error<GetLocationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_lang = x_lang;
    let p_query_station_type = station_type;

    let uri_str = format!("{}/consts/locations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_station_type {
        req_builder = req_builder.query(&[("stationType", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Country&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Country&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLocationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Methods are marked as active if they are available and accept payments in the currency passed in X-Currency parameter.
pub async fn get_online_paymenth_methods(
    configuration: &configuration::Configuration,
    x_lang: Option<&str>,
    x_currency: Option<&str>,
) -> Result<Vec<models::PaymentMethod>, Error<GetOnlinePaymenthMethodsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_lang = x_lang;
    let p_header_x_currency = x_currency;

    let uri_str = format!("{}/consts/paymentMethods", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_currency {
        req_builder = req_builder.header("X-Currency", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PaymentMethod&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PaymentMethod&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOnlinePaymenthMethodsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Note the difference between tariffs, seat classes and vehicle standards
pub async fn get_seat_classes(
    configuration: &configuration::Configuration,
    x_lang: Option<&str>,
) -> Result<Vec<models::SeatClass>, Error<GetSeatClassesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_lang = x_lang;

    let uri_str = format!("{}/consts/seatClasses", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SeatClass&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SeatClass&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSeatClassesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Note the difference between tariffs, seat classes and vehicle standards
pub async fn get_tariffs(
    configuration: &configuration::Configuration,
    x_lang: Option<&str>,
) -> Result<Vec<models::Tariff>, Error<GetTariffsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_lang = x_lang;

    let uri_str = format!("{}/consts/tariffs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Tariff&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Tariff&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTariffsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_timetables(
    configuration: &configuration::Configuration,
    x_lang: Option<&str>,
    connection_id: Option<i64>,
) -> Result<Vec<models::Timetable>, Error<GetTimetablesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_lang = x_lang;
    let p_query_connection_id = connection_id;

    let uri_str = format!("{}/consts/timetables", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_connection_id {
        req_builder = req_builder.query(&[("connectionId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Timetable&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Timetable&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimetablesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Note the difference between tariffs, seat classes and vehicle standards
pub async fn get_vehicle_standards(
    configuration: &configuration::Configuration,
    x_lang: Option<&str>,
) -> Result<Vec<models::VehicleStandard>, Error<GetVehicleStandardsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_lang = x_lang;

    let uri_str = format!("{}/consts/vehicleStandards", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::VehicleStandard&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::VehicleStandard&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetVehicleStandardsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
