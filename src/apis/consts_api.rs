/*
 * RegioJet API
 *
 * A set of endpoints to interact with RegioJet transport services. Search for connections, book tickets, see the list of served stations and more. All endpoints consume and produce JSON strings, with the exception of ticket printing (/tickets/{ticketId}/print) that produce printable HTML code.
 *
 * The version of the OpenAPI document: 1.2.0
 * Contact: developers@studentagency.cz
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, configuration};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for typed errors of method [`get_action_prices`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetActionPricesError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_carriers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCarriersError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_city_pairs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCityPairsError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_integrated_transport_systems`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetIntegratedTransportSystemsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_line_symbols`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLineSymbolsError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_line_symbols_by_line_group_code_line_number`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLineSymbolsByLineGroupCodeLineNumberError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_line_time_codes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLineTimeCodesError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_line_time_codes_by_line_group_code_line_number`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLineTimeCodesByLineGroupCodeLineNumberError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_line_timetables`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLineTimetablesError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_lines`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLinesError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_lines_by_departure_station`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLinesByDepartureStationError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_locations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLocationsError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_online_paymenth_methods`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOnlinePaymenthMethodsError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_payment_definitions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPaymentDefinitionsError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_points_of_sales`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPointsOfSalesError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_seat_classes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSeatClassesError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_symbols`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSymbolsError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_tariffs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTariffsError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_timetable_by_bus_connection_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimetableByBusConnectionIdError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_timetables`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimetablesError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_translations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTranslationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_vehicle_standards`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVehicleStandardsError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

pub async fn get_action_prices(
    configuration: &configuration::Configuration,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
    active_only: Option<bool>,
) -> Result<Vec<models::ActionPrice>, Error<GetActionPricesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;
    let p_query_active_only = active_only;

    let uri_str = format!("{}/consts/actionPrices", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_active_only {
        req_builder = req_builder.query(&[("activeOnly", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ActionPrice&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ActionPrice&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetActionPricesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_carriers(
    configuration: &configuration::Configuration,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<Vec<models::Carrier>, Error<GetCarriersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!("{}/consts/carriers", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Carrier&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Carrier&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCarriersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_city_pairs(
    configuration: &configuration::Configuration,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
    x_currency: Option<&str>,
    from_city_id: Option<i64>,
    to_city_id: Option<i64>,
    number_of_transfers: Option<i32>,
) -> Result<Vec<models::CityPair>, Error<GetCityPairsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;
    let p_header_x_currency = x_currency;
    let p_query_from_city_id = from_city_id;
    let p_query_to_city_id = to_city_id;
    let p_query_number_of_transfers = number_of_transfers;

    let uri_str = format!("{}/consts/cityPairs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_from_city_id {
        req_builder = req_builder.query(&[("fromCityId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_to_city_id {
        req_builder = req_builder.query(&[("toCityId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_number_of_transfers {
        req_builder = req_builder.query(&[("numberOfTransfers", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_currency {
        req_builder = req_builder.header("X-Currency", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::CityPair&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::CityPair&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCityPairsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns list as tree of ITS, superzones and zones.
pub async fn get_integrated_transport_systems(
    configuration: &configuration::Configuration,
    x_application_origin: Option<&str>,
) -> Result<Vec<models::IntegratedTransportSystem>, Error<GetIntegratedTransportSystemsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_application_origin = x_application_origin;

    let uri_str = format!(
        "{}/consts/integrated-transport-systems",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::IntegratedTransportSystem&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::IntegratedTransportSystem&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetIntegratedTransportSystemsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_line_symbols(
    configuration: &configuration::Configuration,
    timetable_id: i64,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<Vec<models::Symbol>, Error<GetLineSymbolsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_timetable_id = timetable_id;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/consts/timetables/{timetableId}/symbols",
        configuration.base_path,
        timetableId = p_path_timetable_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Symbol&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Symbol&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLineSymbolsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_line_symbols_by_line_group_code_line_number(
    configuration: &configuration::Configuration,
    code: &str,
    number: i32,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<Vec<models::Symbol>, Error<GetLineSymbolsByLineGroupCodeLineNumberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_code = code;
    let p_path_number = number;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/consts/timetables/{code}/{number}/symbols",
        configuration.base_path,
        code = crate::apis::urlencode(p_path_code),
        number = p_path_number
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Symbol&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Symbol&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLineSymbolsByLineGroupCodeLineNumberError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_line_time_codes(
    configuration: &configuration::Configuration,
    timetable_id: i64,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<Vec<models::TimeCode>, Error<GetLineTimeCodesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_timetable_id = timetable_id;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/consts/timetables/{timetableId}/time-codes",
        configuration.base_path,
        timetableId = p_path_timetable_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TimeCode&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TimeCode&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLineTimeCodesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_line_time_codes_by_line_group_code_line_number(
    configuration: &configuration::Configuration,
    code: &str,
    number: i32,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<Vec<models::TimeCode>, Error<GetLineTimeCodesByLineGroupCodeLineNumberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_code = code;
    let p_path_number = number;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/consts/timetables/{code}/{number}/time-codes",
        configuration.base_path,
        code = crate::apis::urlencode(p_path_code),
        number = p_path_number
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TimeCode&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TimeCode&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLineTimeCodesByLineGroupCodeLineNumberError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_line_timetables(
    configuration: &configuration::Configuration,
    code: &str,
    number: i32,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
    direction: Option<&str>,
    timetable: Option<i64>,
) -> Result<Vec<models::Timetable>, Error<GetLineTimetablesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_code = code;
    let p_path_number = number;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;
    let p_query_direction = direction;
    let p_query_timetable = timetable;

    let uri_str = format!(
        "{}/consts/timetables/{code}/{number}",
        configuration.base_path,
        code = crate::apis::urlencode(p_path_code),
        number = p_path_number
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_direction {
        req_builder = req_builder.query(&[("direction", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timetable {
        req_builder = req_builder.query(&[("timetable", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Timetable&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Timetable&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLineTimetablesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_lines(
    configuration: &configuration::Configuration,
    from_station_id: i64,
    to_station_id: i64,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<Vec<models::TimeTableLine>, Error<GetLinesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_from_station_id = from_station_id;
    let p_path_to_station_id = to_station_id;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/consts/lines/{fromStationId}/{toStationId}",
        configuration.base_path,
        fromStationId = p_path_from_station_id,
        toStationId = p_path_to_station_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TimeTableLine&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TimeTableLine&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLinesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_lines_by_departure_station(
    configuration: &configuration::Configuration,
    station_id: i64,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
    code: Option<Vec<String>>,
) -> Result<Vec<models::TimeTableLine>, Error<GetLinesByDepartureStationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_station_id = station_id;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;
    let p_query_code = code;

    let uri_str = format!(
        "{}/consts/lines/{stationId}",
        configuration.base_path,
        stationId = p_path_station_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_code {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("code".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "code",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TimeTableLine&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TimeTableLine&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLinesByDepartureStationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_locations(
    configuration: &configuration::Configuration,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
    station_type: Option<&str>,
    include_unavailable: Option<bool>,
) -> Result<Vec<models::Country>, Error<GetLocationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;
    let p_query_station_type = station_type;
    let p_query_include_unavailable = include_unavailable;

    let uri_str = format!("{}/consts/locations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_station_type {
        req_builder = req_builder.query(&[("stationType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_unavailable {
        req_builder = req_builder.query(&[("includeUnavailable", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Country&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Country&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLocationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Methods are marked as active if they are available and accept payments in the currency passed in X-Currency parameter.
pub async fn get_online_paymenth_methods(
    configuration: &configuration::Configuration,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
    x_currency: Option<&str>,
) -> Result<Vec<models::PaymentMethod>, Error<GetOnlinePaymenthMethodsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;
    let p_header_x_currency = x_currency;

    let uri_str = format!("{}/consts/paymentMethods", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_currency {
        req_builder = req_builder.header("X-Currency", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PaymentMethod&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PaymentMethod&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOnlinePaymenthMethodsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets list of available payment definitions with allowed currency for each channel.
pub async fn get_payment_definitions(
    configuration: &configuration::Configuration,
    x_lang: Option<&str>,
) -> Result<Vec<models::AllowedPaymentDefinition>, Error<GetPaymentDefinitionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_lang = x_lang;

    let uri_str = format!("{}/consts/paymentDefinitions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::AllowedPaymentDefinition&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::AllowedPaymentDefinition&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPaymentDefinitionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of points of sales.
pub async fn get_points_of_sales(
    configuration: &configuration::Configuration,
    x_lang: Option<&str>,
) -> Result<Vec<models::PointOfSale>, Error<GetPointsOfSalesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_lang = x_lang;

    let uri_str = format!("{}/consts/points-of-sales", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PointOfSale&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PointOfSale&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPointsOfSalesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Note the difference between tariffs, seat classes and vehicle standards
pub async fn get_seat_classes(
    configuration: &configuration::Configuration,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<Vec<models::SeatClass>, Error<GetSeatClassesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!("{}/consts/seatClasses", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SeatClass&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SeatClass&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSeatClassesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_symbols(
    configuration: &configuration::Configuration,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<Vec<models::Symbol>, Error<GetSymbolsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!("{}/consts/symbols", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Symbol&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Symbol&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSymbolsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Note the difference between tariffs, seat classes and vehicle standards
pub async fn get_tariffs(
    configuration: &configuration::Configuration,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<Vec<models::Tariff>, Error<GetTariffsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!("{}/consts/tariffs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Tariff&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Tariff&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTariffsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_timetable_by_bus_connection_id(
    configuration: &configuration::Configuration,
    bus_connection_id: i64,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<models::Timetable, Error<GetTimetableByBusConnectionIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_bus_connection_id = bus_connection_id;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/consts/timetables/{busConnectionId}",
        configuration.base_path,
        busConnectionId = p_path_bus_connection_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::Timetable`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Timetable`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimetableByBusConnectionIdError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_timetables(
    configuration: &configuration::Configuration,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
    connection_id: Option<i64>,
) -> Result<Vec<models::Timetable>, Error<GetTimetablesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;
    let p_query_connection_id = connection_id;

    let uri_str = format!("{}/consts/timetables", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_connection_id {
        req_builder = req_builder.query(&[("connectionId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Timetable&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Timetable&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimetablesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_translations(
    configuration: &configuration::Configuration,
    language: &str,
    x_application_origin: Option<&str>,
) -> Result<std::collections::HashMap<String, String>, Error<GetTranslationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_language = language;
    let p_header_x_application_origin = x_application_origin;

    let uri_str = format!(
        "{}/consts/translations/{language}",
        configuration.base_path,
        language = crate::apis::urlencode(p_path_language)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, String&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, String&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTranslationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Note the difference between tariffs, seat classes and vehicle standards
pub async fn get_vehicle_standards(
    configuration: &configuration::Configuration,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<Vec<models::VehicleStandard>, Error<GetVehicleStandardsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!("{}/consts/vehicleStandards", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::VehicleStandard&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::VehicleStandard&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetVehicleStandardsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
