/*
 * RegioJet API
 *
 * A set of endpoints to interact with RegioJet transport services. Search for connections, book tickets, see the list of served stations and more. All endpoints consume and produce JSON strings, with the exception of ticket printing (/tickets/{ticketId}/print) that produce printable HTML code.
 *
 * The version of the OpenAPI document: 1.2.0
 * Contact: developers@studentagency.cz
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, configuration};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for typed errors of method [`cancel_sro_ticket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelSroTicketError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_sro_tickets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllSroTicketsError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sro_ticket_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSroTicketByIdError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

pub async fn cancel_sro_ticket(
    configuration: &configuration::Configuration,
    sro_ticket_id: i64,
    body: models::CancelTicketRequest,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
    x_tx_token: Option<&str>,
) -> Result<models::SuccessResponse, Error<CancelSroTicketError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_sro_ticket_id = sro_ticket_id;
    let p_body_body = body;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;
    let p_header_x_tx_token = x_tx_token;

    let uri_str = format!(
        "{}/tickets/RJ_SRO/{sroTicketId}",
        configuration.base_path,
        sroTicketId = p_path_sro_ticket_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_tx_token {
        req_builder = req_builder.header("X-TxToken", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::SuccessResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SuccessResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelSroTicketError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_all_sro_tickets(
    configuration: &configuration::Configuration,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
    limit: Option<i32>,
    offset: Option<i32>,
    departure_from: Option<String>,
    departure_to: Option<String>,
    arrival_from: Option<String>,
    arrival_to: Option<String>,
    ticket_states: Option<Vec<String>>,
    sort_property: Option<&str>,
    sort_direction: Option<&str>,
) -> Result<Vec<models::SroTicket>, Error<GetAllSroTicketsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;
    let p_query_limit = limit;
    let p_query_offset = offset;
    let p_query_departure_from = departure_from;
    let p_query_departure_to = departure_to;
    let p_query_arrival_from = arrival_from;
    let p_query_arrival_to = arrival_to;
    let p_query_ticket_states = ticket_states;
    let p_query_sort_property = sort_property;
    let p_query_sort_direction = sort_direction;

    let uri_str = format!("{}/tickets/RJ_SRO", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_departure_from {
        req_builder = req_builder.query(&[("departureFrom", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_departure_to {
        req_builder = req_builder.query(&[("departureTo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_arrival_from {
        req_builder = req_builder.query(&[("arrivalFrom", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_arrival_to {
        req_builder = req_builder.query(&[("arrivalTo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ticket_states {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("ticketStates".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "ticketStates",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_sort_property {
        req_builder = req_builder.query(&[("sortProperty", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_sort_direction {
        req_builder = req_builder.query(&[("sortDirection", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SroTicket&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SroTicket&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAllSroTicketsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_sro_ticket_by_id(
    configuration: &configuration::Configuration,
    sro_ticket_id: i64,
    x_application_origin: Option<&str>,
    x_lang: Option<&str>,
) -> Result<models::SroTicket, Error<GetSroTicketByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_sro_ticket_id = sro_ticket_id;
    let p_header_x_application_origin = x_application_origin;
    let p_header_x_lang = x_lang;

    let uri_str = format!(
        "{}/tickets/RJ_SRO/{sroTicketId}",
        configuration.base_path,
        sroTicketId = p_path_sro_ticket_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_application_origin {
        req_builder = req_builder.header("X-Application-Origin", param_value.to_string());
    }
    if let Some(param_value) = p_header_x_lang {
        req_builder = req_builder.header("X-Lang", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Token-Hash", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::SroTicket`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SroTicket`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSroTicketByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
